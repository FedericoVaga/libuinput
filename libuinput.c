/*
 *  Copyright Â© 2013 Federico Vaga <federico.vaga@gmail.com>
 *  License: GPLv2
 */

#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <glob.h>
#include <linux/uinput.h>

#define UINPUT_INTERNAL 1
#include "libuinput.h"

/*
 * uinput_open
 * @path: path to the uinput device. If NULL, the default is /dev/uinput
 *
 * It opens the uinput device.
 * It returns an uinput token to use for all operation on uinput
 */
struct uinput_tkn *uinput_open(char *path) {
	struct uinput_token *tkn;

	tkn = malloc(sizeof(struct uinput_token));
	if (!tkn)
		return NULL ;

	tkn->fd = open(path ? path : "/dev/uinput", O_WRONLY | O_NONBLOCK);
	if (tkn->fd < 0) {
		free(tkn);
		return NULL ;
	}
	return (void *) tkn;
}

/*
 * uinput_close
 * @tkn: the library token created by uinput_open
 *
 * It closes the uinput device
 */
void uinput_close(struct uinput_tkn *tkn) {
	struct uinput_token *t = (void *) tkn;

	if (t->fd >= 0)
		close(t->fd);
}


/*
 * flush_kmsg
 * @fd: file descriptor of kmsg char device
 */
static void flush_kmsg(int fd)
{
	struct timeval timeout = {0, 0}; /* immediatly */
	char buf[1024];
	fd_set set;
	int err;

	while (1) {
		FD_ZERO(&set);
		FD_SET(fd, &set);
		err = select(fd + 1, &set, NULL, NULL, &timeout);
		if (err != 1) /* stop if not ready */
			break;
		/* otherwise, read */
		read(fd, &buf, 1024);
	}
}


/*
 * uinput_get_event
 * @t: internal uinput token
 *
 * It set the path to the event char device associated to the created uinput
 * device.
 */
static void uinput_get_event(int fd, struct uinput_token *t)
{
	struct timeval timeout = {1, 0}; /* Immediately */
	char buf[128];
	char path[128];
	glob_t glob_event;
	fd_set set;
	int err, found = 0;
	char *tmp;

	t->input_no = -1;
	t->event_no = -1;
	t->event_dev_path[0] = 0;

	printf("Looking for event ...\n\n\n");
	do {
		FD_ZERO(&set);
		FD_SET(fd, &set);
		err = select(fd + 1, &set, NULL, NULL, &timeout);
		if (err != 1) /* stop if timeout or error */
			return;

		/* otherwise, read */
		read(fd, buf, 128);

		/*
		 * Look for the sysfs path generated by uinput. We cannot use
		 * sscanf() directly because the kmsg output depend of kernel
		 * configuration. First we look for the path, then we use
		 * sscanf() to get the input device number
		 */
		tmp = strstr(buf, "/devices/virtual/input/input");
		err = sscanf(tmp, "/devices/virtual/input/input%i",
			     &t->input_no);
		if (t->input_no < 0)
			continue;

		/* Looking for the associated event char device in sysfs */
		sprintf(path, "/sys/devices/virtual/input/input%i/event*",
			t->input_no);
		glob(path, 0, NULL, &glob_event);

		if (glob_event.gl_pathc == 1) {
			sscanf(glob_event.gl_pathv[0],
			       "/sys/devices/virtual/input/input%*i/event%i",
			       &t->event_no);
			sprintf(t->event_dev_path, "/dev/input/event%d",
				t->event_no);
			found = 1;
		}

		globfree(&glob_event);
	} while(!found); /* If not found, try again */
}


/*
 * uinput_create_new_device
 * @tkn: the library token created by uinput_open
 * @dev: description of the new input device to create
 *
 * It creates a new uinput device based on the information within the data
 * structure uinput_user_dev. Remember, you must set the list of supported
 * events before create a new device.
 */
int uinput_create_new_device(struct uinput_tkn *tkn,
		struct uinput_user_dev *dev) {
	struct uinput_token *t = (void *) tkn;
	ssize_t len;
	int err, fd;


	if (!tkn || !dev) {
		errno = EINVAL;
		return -1;
	}

	fd = open("/dev/kmsg", O_RDONLY);
	if (fd > 0)
		flush_kmsg(fd);

	/* Write the configuration of the new input device */
	len = write(t->fd, dev, sizeof(struct uinput_user_dev));
	if (len != sizeof(struct uinput_user_dev)) {
		errno = EIO;
		return -1;
	}
	/* Create the new input device */
	err = ioctl(t->fd, UI_DEV_CREATE);
	if (err == -1) {
		return err;
	}

	/* Device created correctly */
	t->dev = dev;

	if (fd > 0) {
		uinput_get_event(fd, t);
		close(fd);
	}


	return 0;
}

/*
 * uinput_destroy
 * @tkn: the library token created by uinput_open
 *
 * It destroys the device associated to the token
 */
int uinput_destroy(struct uinput_tkn *tkn) {
	struct uinput_token *t = (void *) tkn;
	int err;

	t->event_dev_path[0] = 0;
	t->event_no = -1;

	err = ioctl(t->fd, UI_DEV_DESTROY);
	if (err == -1) {
		fprintf(stderr, "Error while destroying device \"%s\"",
			t->dev->name);
	}
	t->dev = NULL;
	return err;
}

/*
 * uinput_enable_event
 * @tkn: the library token created by uinput_open
 * @type: type of event to enable (read input.h for the list)
 *
 * It enables a type of event
 */
int uinput_enable_event(struct uinput_tkn *tkn, int type) {
	struct uinput_token *t = (void *) tkn;

	return ioctl(t->fd, UI_SET_EVBIT, type);
}

/*
 * uinput_enable_event
 * @tkn: the library token created by uinput_open
 * @type: type of event to set (read input.h for the list)
 * @code: code of the event
 *
 * It sets a valid event handled by the device that you are creating
 */
int uinput_set_valid_event(struct uinput_tkn *tkn, int type, int code) {
	struct uinput_token *t = (void *) tkn;

	return ioctl(t->fd, type, code);
}

/*
 * uinput_set_valid_events
 * @tkn: the library token created by uinput_open
 * @ev: list of events
 * @n: number of events in the list
 *
 * It sets valid events handled by the device that you are creating. It is like
 * uinput_set_valid_event() but it operates on an array of events
 */
int uinput_set_valid_events(struct uinput_tkn *tkn, struct input_event *ev,
		unsigned int n) {
	int i, err = 0;

	for (i = 0; i < n; ++i) {
		err = uinput_set_valid_event(tkn, ev[i].type, ev[i].code);
		if (err)
			break;
	}

	return err;
}

/*
 * uinput_send_event
 * @tkn: the library token created by uinput_open
 * @event: the event to send to device
 *
 * It sends an event to the device
 */
int uinput_send_event(struct uinput_tkn *tkn, struct input_event *ev) {
	struct uinput_token *t = (void *) tkn;

	ssize_t len;

	gettimeofday(&ev->time, 0);
	len = write(t->fd, ev, sizeof(struct input_event));
	if (len != sizeof(struct input_event)) {
		return -1;
	}
	return 0;
}

/*
 * uinput_send_events
 * @tkn: the library token created by uinput_open
 * @event: list of events to send to device
 * @n: number of events in the list
 *
 * It sends a list of events to the device
 */
int uinput_send_events(struct uinput_tkn *tkn, struct input_event *event,
		       unsigned int n, int do_sync) {
	int i, err = 0;
	struct input_event ev = {{0, 0}, EV_SYN, SYN_REPORT, 0};

	for (i = 0; i < n; ++i) {
		err = uinput_send_event(tkn, &event[i]);
		if (err) {
		  fprintf(stderr, "Cannot send event, err %d: %s\n",
			  errno, strerror(errno));
		  break;
		}
	}

	if (!do_sync) /* Skip syncronization */
	    return err;

	/* Do Synchronization */
	err = uinput_send_event(tkn, &ev);
	if (err) {
	    fprintf(stderr, "Cannot sync event, err %d: %s\n",
		    errno, strerror(errno));
	}

	return err;
}


/*
 * uinput_get_event_no
 * @tkn: the library token created by uinput_open
 *
 * It returns the event number associated to the uinput device. It returns -1
 * if the library was not able to determinate the input device number.
 */
int uinput_get_input_no(struct uinput_tkn *tkn)
{
	struct uinput_token *t = (void *) tkn;

	return t->input_no;
}

/*
 * uinput_get_event_no
 * @tkn: the library token created by uinput_open
 *
 * It returns the event number associated to the uinput device. It returns -1
 * if the library was not able to determinate the event device number
 */
int uinput_get_event_no(struct uinput_tkn *tkn)
{
	struct uinput_token *t = (void *) tkn;

	return t->event_no;
}

/*
 * uinput_get_event_path
 * @tkn: the library token created by uinput_open
 *
 * It returns the string of the char device event associated to the uinput
 * device. It returns NULL if the library was not able to determinate the
 * path to the event char device.
 */
char *uinput_get_event_path(struct uinput_tkn *tkn)
{
	struct uinput_token *t = (void *) tkn;

	if (t->event_dev_path[0] == 0)
		return NULL;
	return t->event_dev_path;
}
