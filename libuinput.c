/**
 *  @author Federico Vaga <federico.vaga@ gmail.com>
 *  @date 2013
 *  @copyright Â© 2013 Federico Vaga <federico.vaga@ gmail.com>, License: GPLv2
 *  @version 0.2
 */

#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <glob.h>
#include <linux/uinput.h>

#define UINPUT_INTERNAL 1
#include "libuinput.h"

struct uinput_tkn *uinput_open(char *path) {
	struct uinput_token *tkn;

	tkn = malloc(sizeof(struct uinput_token));
	if (!tkn)
		return NULL ;

	tkn->fd = open(path ? path : "/dev/uinput", O_WRONLY | O_NONBLOCK);
	if (tkn->fd < 0) {
		free(tkn);
		return NULL ;
	}
	return (void *) tkn;
}


void uinput_close(struct uinput_tkn *tkn) {
	struct uinput_token *t = (void *) tkn;

	if (t->fd >= 0)
		close(t->fd);
}


/**
 * It flushes the buffer of a kmsg file descriptor.
 *
 * @param[in] fd is file descriptor of kmsg char device
 */
static void flush_kmsg(int fd)
{
	struct timeval timeout = {0, 0}; /* immediatly */
	char buf[1024];
	fd_set set;
	int err;

	while (1) {
		FD_ZERO(&set);
		FD_SET(fd, &set);
		err = select(fd + 1, &set, NULL, NULL, &timeout);
		if (err != 1) /* stop if not ready */
			break;
		/* otherwise, read */
		read(fd, &buf, 1024);
	}
}


/**
 * It set the path to the event char device associated to the created uinput
 * device.
 *
 * @param t is internal uinput token
 */
static void uinput_get_event(int fd, struct uinput_token *t)
{
	struct timeval timeout = {1, 0}; /* Immediately */
	char buf[128];
	char path[128];
	glob_t glob_event;
	fd_set set;
	int err, found = 0;
	char *tmp;

	t->input_no = -1;
	t->event_no = -1;
	t->event_dev_path[0] = 0;

	printf("Looking for event ...\n\n\n");
	do {
		FD_ZERO(&set);
		FD_SET(fd, &set);
		err = select(fd + 1, &set, NULL, NULL, &timeout);
		if (err != 1) /* stop if timeout or error */
			return;

		/* otherwise, read */
		read(fd, buf, 128);

		/*
		 * Look for the sysfs path generated by uinput. We cannot use
		 * sscanf() directly because the kmsg output depend of kernel
		 * configuration. First we look for the path, then we use
		 * sscanf() to get the input device number
		 */
		tmp = strstr(buf, "/devices/virtual/input/input");
		err = sscanf(tmp, "/devices/virtual/input/input%i",
			     &t->input_no);
		if (t->input_no < 0)
			continue;

		/* Looking for the associated event char device in sysfs */
		sprintf(path, "/sys/devices/virtual/input/input%i/event*",
			t->input_no);
		glob(path, 0, NULL, &glob_event);

		if (glob_event.gl_pathc == 1) {
			sscanf(glob_event.gl_pathv[0],
			       "/sys/devices/virtual/input/input%*i/event%i",
			       &t->event_no);
			sprintf(t->event_dev_path, "/dev/input/event%d",
				t->event_no);
			found = 1;
		}

		globfree(&glob_event);
	} while(!found); /* If not found, try again */
}


int uinput_create_new_device(struct uinput_tkn *tkn,
		struct uinput_user_dev *dev) {
	struct uinput_token *t = (void *) tkn;
	ssize_t len;
	int err, fd;


	if (!tkn || !dev) {
		errno = EINVAL;
		return -1;
	}

	fd = open("/dev/kmsg", O_RDONLY);
	if (fd > 0)
		flush_kmsg(fd);

	/* Write the configuration of the new input device */
	len = write(t->fd, dev, sizeof(struct uinput_user_dev));
	if (len != sizeof(struct uinput_user_dev)) {
		errno = EIO;
		return -1;
	}
	/* Create the new input device */
	err = ioctl(t->fd, UI_DEV_CREATE);
	if (err == -1) {
		return err;
	}

	/* Device created correctly */
	t->dev = dev;

	if (fd > 0) {
		uinput_get_event(fd, t);
		close(fd);
	}


	return 0;
}


int uinput_destroy(struct uinput_tkn *tkn) {
	struct uinput_token *t = (void *) tkn;
	int err;

	t->event_dev_path[0] = 0;
	t->event_no = -1;

	err = ioctl(t->fd, UI_DEV_DESTROY);
	if (err == -1) {
		fprintf(stderr, "Error while destroying device \"%s\"",
			t->dev->name);
	}
	t->dev = NULL;
	return err;
}


int uinput_enable_event(struct uinput_tkn *tkn, int type) {
	struct uinput_token *t = (void *) tkn;

	return ioctl(t->fd, UI_SET_EVBIT, type);
}


int uinput_set_valid_event(struct uinput_tkn *tkn, int type, int code) {
	struct uinput_token *t = (void *) tkn;

	return ioctl(t->fd, type, code);
}


int uinput_set_valid_events(struct uinput_tkn *tkn, struct input_event *ev,
		unsigned int n) {
	int i, err = 0;

	for (i = 0; i < n; ++i) {
		err = uinput_set_valid_event(tkn, ev[i].type, ev[i].code);
		if (err)
			break;
	}

	return err;
}


int uinput_send_event(struct uinput_tkn *tkn, struct input_event *ev) {
	struct uinput_token *t = (void *) tkn;

	ssize_t len;

	gettimeofday(&ev->time, 0);
	len = write(t->fd, ev, sizeof(struct input_event));
	if (len != sizeof(struct input_event)) {
		return -1;
	}
	return 0;
}


int uinput_send_events(struct uinput_tkn *tkn, struct input_event *event,
		       unsigned int n, int do_sync) {
	int i, err = 0;
	struct input_event ev = {{0, 0}, EV_SYN, SYN_REPORT, 0};

	for (i = 0; i < n; ++i) {
		err = uinput_send_event(tkn, &event[i]);
		if (err) {
		  fprintf(stderr, "Cannot send event, err %d: %s\n",
			  errno, strerror(errno));
		  break;
		}
	}

	if (!do_sync) /* Skip syncronization */
	    return err;

	/* Do Synchronization */
	err = uinput_send_event(tkn, &ev);
	if (err) {
	    fprintf(stderr, "Cannot sync event, err %d: %s\n",
		    errno, strerror(errno));
	}

	return err;
}



int uinput_get_input_no(struct uinput_tkn *tkn)
{
	struct uinput_token *t = (void *) tkn;

	return t->input_no;
}


int uinput_get_event_no(struct uinput_tkn *tkn)
{
	struct uinput_token *t = (void *) tkn;

	return t->event_no;
}


char *uinput_get_event_path(struct uinput_tkn *tkn)
{
	struct uinput_token *t = (void *) tkn;

	if (t->event_dev_path[0] == 0)
		return NULL;
	return t->event_dev_path;
}
